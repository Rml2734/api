// ===== ARCHIVO FINAL: cuentas.js (con Manejo de Resultado de pedirCuenta Mejorado) =====
/*
var express = require("express");
var bcrypt = require("bcrypt");
var jwt = require('jsonwebtoken');
var createError = require("http-errors"); // Aseg√∫rate de tener esta l√≠nea si la usas (ej. en crearFicha)
var cors = require("cors"); // üÜï Nuevo requerimiento de CORS

var router = express.Router();
// Aseg√∫rate que las funciones importadas hagan lo que esperas
const { pedirCuenta, crear, borrar } = require("../db/pedidos");
const { body, validationResult } = require("express-validator");
const pool = require('../db/configuracion'); // ‚úÖ Importar pool
// üÜï Importar configuraci√≥n CORS del app.js
// üü¢ IMPORTACI√ìN CORRECTA üü¢
const { corsOptions } = require("../config/cors"); // üëà Nueva importaci√≥n desde config/

// üÜï 1. Manejar solicitudes OPTIONS para login
router.options("/login", cors(corsOptions), (req, res) => {
    console.log("üî•üî•üî• MANEJANDO OPTIONS PARA /login");
    res.header("Access-Control-Allow-Methods", "POST, OPTIONS");
    res.header("Access-Control-Allow-Headers", "Content-Type, Authorization, Origin");
    res.status(200).end();
});

// Middleware de autenticaci√≥n (para otras rutas)
const autenticar = (req, res, next) => {
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) return res.status(401).json({ error: "Acceso no autorizado" });
    jwt.verify(token, process.env.JWT_SECRET || "secreto", (err, decoded) => {
        if (err) return res.status(403).json({ error: "Token inv√°lido" });
        req.usuario = { id: decoded.id, email: decoded.usuario };
        next();
    });
};
*/
/* POST Crear cuenta */
/*
router.post(
    "/signup",
    body("usuario").isEmail(),
    body("clave").isLength({ min: 5 }),
    async function (req, res, next) {
        console.log("-> Entrando a /api/signup");
        try {
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                console.log("Errores de validaci√≥n en signup:", errors.array());
                return res.status(400).json({ errors: errors.array() });
            }
            const nuevaCuenta = req.body;
            console.log("Intentando crear cuenta para:", nuevaCuenta.usuario);
            const hash = await bcrypt.hash(nuevaCuenta.clave, 12);
            crear("cuentas", { usuario: nuevaCuenta.usuario, hash }, async (err, cuenta) => {
                if (err) { console.error("Error al crear cuenta en DB:", err); return next(err); }
                if (!cuenta || !cuenta.usuario) { console.error("Error: La funci√≥n 'crear' no devolvi√≥ una cuenta v√°lida."); return next(new Error("Error al crear la cuenta")); }
                console.log("Cuenta creada, generando token para:", cuenta.usuario);
                try {
                    const ficha = await crearFicha(cuenta.usuario);
                    console.log("Token generado, enviando respuesta.");
                    res.status(201).send({ token: ficha });
                } catch(fichaError) {
                    console.error("Error al crear ficha/token despu√©s de crear cuenta:", fichaError);
                    next(fichaError);
                }
            });
        } catch (error) {
            console.error("Error inesperado en /api/signup:", error);
            next(error);
        }
    }
);
*/

/* POST Login (L√≥gica Completa Restaurada + Manejo Mejorado de pedirCuenta) */
/*
router.post(
    "/login",
    cors(corsOptions), // üÜï Aplicar CORS espec√≠ficamente aqu√≠
    body("usuario").isEmail(),
    body("clave").isLength({ min: 5 }),
    async function (req, res, next) {
        // üëá *** Log inicial del handler *** üëá
        console.log("üî•üî•üî• ENTRANDO AL HANDLER POST /api/login (L√≥gica Completa) üî•üî•üî•");
        try {
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                console.log("Errores de validaci√≥n en login:", errors.array());
                // Aseg√∫rate de no continuar si hay errores de validaci√≥n
                return res.status(400).json({ errors: errors.array() });
            }

            const login = req.body;
            console.log(`Intentando login para usuario: ${login.usuario}`);

            // üëá *** Log ANTES de llamar a la BD *** üëá
            console.log("PASO 1: Llamando a pedirCuenta...");
            pedirCuenta(login.usuario, async (err, cuentaArray) => {
                // üëá *** Log DESPU√âS de llamar a la BD (o si hay error) *** üëá
                if (err) {
                    console.error(`üí• ERROR en pedirCuenta para ${login.usuario}:`, err);
                    return next(err); // Pasa el error al manejador global
                }
                console.log("PASO 2: Respuesta de pedirCuenta recibida.");
                console.log("PASO 2b: Contenido de cuentaArray:", cuentaArray); // Log para depuraci√≥n

                const cuenta = cuentaArray && cuentaArray.length > 0 ? cuentaArray[0] : null;

                if (!cuenta) {
                    console.log(`Cuenta no encontrada para ${login.usuario}`);
                    // Devuelve un error claro y termina la ejecuci√≥n
                    return res.status(404).send({ error: "Usuario no encontrado" });
                }
                console.log(`PASO 3: Cuenta encontrada para ${login.usuario}. ID: ${cuenta.id}. Comparando clave...`);

                // üëá *** Log ANTES de bcrypt *** üëá
                let result;
                try {
                    console.log("PASO 4: Llamando a bcrypt.compare...");
                    result = await bcrypt.compare(login.clave, cuenta.hash);
                    // üëá *** Log DESPU√âS de bcrypt *** üëá
                    console.log("PASO 5: bcrypt.compare completado. Resultado:", result);
                } catch (bcryptError) {
                    console.error(`üí• ERROR en bcrypt.compare para ${login.usuario}:`, bcryptError);
                    return next(bcryptError); // Pasa el error
                }

                if (!result) {
                    console.log(`Clave incorrecta para ${login.usuario}`);
                    // Devuelve un error claro y termina la ejecuci√≥n
                    return res.status(401).send({ error: "Credenciales inv√°lidas" });
                }
                console.log(`PASO 6: Clave correcta para ${login.usuario}. Creando token...`);

                // üëá *** Log ANTES de crear ficha/token *** üëá
                try {
                    console.log("PASO 7: Llamando a crearFicha...");
                    const ficha = await crearFicha(login.usuario);
                    // üëá *** Log DESPU√âS de crear ficha/token *** üëá
                    console.log("PASO 8: Ficha/Token creado exitosamente.");
                    console.log(`   Enviando token para ${login.usuario}.`);
                    res.send({ token: ficha }); // Env√≠a el token real
                } catch (fichaError) {
                    console.error(`üí• ERROR al crear ficha/token para ${login.usuario}:`, fichaError);
                    next(fichaError); // Pasa el error
                }
            }); // Fin del callback de pedirCuenta
        } catch (error) {
            // Captura cualquier error s√≠ncrono inesperado al inicio del handler
            console.error("üí• Error inesperado GENERAL en POST /api/login:", error);
            next(error); // Pasa el error al manejador global
        }
    } // Fin de la funci√≥n async del handler
);


// Ruta DELETE /api/usuarios/:id para eliminar usuario autenticado
router.delete('/usuarios/:id', autenticar, async (req, res, next) => {
    if (!req.usuario || req.usuario.id !== parseInt(req.params.id, 10)) {
        const userId = req.usuario ? req.usuario.id : 'desconocido';
        console.warn(`Intento no autorizado de borrar usuario ${req.params.id} por usuario ${userId}`);
        return res.status(403).json({ error: "No tienes permiso para borrar este usuario" });
    }
    try {
        const usuarioId = parseInt(req.params.id, 10);
        if (isNaN(usuarioId)) { return res.status(400).json({ error: "ID de usuario inv√°lido" }); }
        console.log(`Ô∏èüóëÔ∏è Intentando eliminar usuario y sus metas con ID: ${usuarioId}`);
        console.log(`  Borrando metas para cuenta_id: ${usuarioId}...`);

        // Importa configuracion.js en lugar de conexion.js
        const db = require('../db/configuracion');

        // Eliminar metas usando el nombre de columna correcto 'cuenta_id'
        await pool.query('DELETE FROM metas WHERE cuenta_id = $1', [usuarioId]);

        console.log(`  Borrando cuenta con id: ${usuarioId}...`);

        // Eliminar la cuenta
        await pool.query('DELETE FROM cuentas WHERE id = $1', [usuarioId]);

        console.log(`‚úÖ Usuario y metas eliminados para ID: ${usuarioId}`);
        res.status(204).end();
    } catch (error) {
        console.error("‚ùå Error en la ruta de eliminaci√≥n /api/usuarios/:id :", error);
        next(error);
    }
});




// Funci√≥n para crear el token JWT
function crearFicha(email) {
    return new Promise((resolve, reject) => {
        pedirCuenta(email, (err, [cuenta]) => {
            if (err) { console.error(`Error en pedirCuenta dentro de crearFicha para ${email}:`, err); return reject(err); }
            if (!cuenta) { console.error(`Cuenta no encontrada dentro de crearFicha para ${email}`); return reject(createError(404, "Cuenta no encontrada al crear ficha")); }
            if (!cuenta.id) { console.error("‚ùå Error: La cuenta recuperada no tiene ID en crearFicha"); return reject(createError(500,"Error interno del servidor: cuenta sin ID")); }
            console.log(`Creando ficha JWT para usuario: ${email}, ID: ${cuenta.id}`);
            let ficha;
            try {
                ficha = jwt.sign( { exp: Math.floor(Date.now() / 1000) + (60 * 60), usuario: email, id: cuenta.id }, process.env.JWT_SECRET || "secreto", { algorithm: 'HS256' } );
            } catch(jwtError) { console.error("Error al firmar JWT:", jwtError); return reject(createError(500, "Error al generar token")); }
            console.log("Ficha JWT creada exitosamente.");
            resolve(ficha);
        });
    });
}

module.exports = router;

*/


var express = require("express");
var bcrypt = require("bcrypt");
var jwt = require('jsonwebtoken');
var createError = require("http-errors"); // Aseg√∫rate de tener esta l√≠nea si la usas (ej. en crearFicha)
var cors = require("cors"); // üÜï Nuevo requerimiento de CORS

var router = express.Router();
// Aseg√∫rate que las funciones importadas hagan lo que esperas
const { pedirCuenta, crear, borrar } = require("../db/pedidos");
const { body, validationResult } = require("express-validator");
const pool = require('../db/configuracion'); // ‚úÖ Importar pool
// üÜï Importar configuraci√≥n CORS del app.js
// üü¢ IMPORTACI√ìN CORRECTA üü¢
const { corsOptions } = require("../config/cors"); // üëà Nueva importaci√≥n desde config/

// üÜï 1. Manejar solicitudes OPTIONS para login
router.options("/login", cors(corsOptions), (req, res) => {
¬† ¬† console.log("üî•üî•üî• MANEJANDO OPTIONS PARA /login");
¬† ¬† res.header("Access-Control-Allow-Methods", "POST, OPTIONS");
¬† ¬† res.header("Access-Control-Allow-Headers", "Content-Type, Authorization, Origin");
¬† ¬† res.status(200).end();
});

// Middleware de autenticaci√≥n (para otras rutas)
const autenticar = (req, res, next) => {
¬† ¬† const token = req.headers.authorization?.split(' ')[1];
¬† ¬† if (!token) return res.status(401).json({ error: "Acceso no autorizado" });
¬† ¬† jwt.verify(token, process.env.JWT_SECRET || "secreto", (err, decoded) => {
¬† ¬† ¬† ¬† if (err) return res.status(403).json({ error: "Token inv√°lido" });
¬† ¬† ¬† ¬† req.usuario = { id: decoded.id, email: decoded.usuario };
¬† ¬† ¬† ¬† next();
¬† ¬† });
};

/* POST Crear cuenta */
router.post(
¬† ¬† "/signup",
¬† ¬† body("usuario").isEmail().withMessage("El formato del correo electr√≥nico es inv√°lido."),
¬† ¬† body("clave").isLength({ min: 5 }).withMessage("La clave debe tener un m√≠nimo de 5 caracteres."), // ‚¨ÖÔ∏è CAMBIO CLAVE AQU√ç
¬† ¬† async function (req, res, next) {
¬† ¬† ¬† ¬† console.log("-> Entrando a /api/signup");
¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† const errors = validationResult(req);
¬† ¬† ¬† ¬† ¬† ¬† if (!errors.isEmpty()) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("Errores de validaci√≥n en signup:", errors.array());
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return res.status(400).json({ errors: errors.array() });
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† const nuevaCuenta = req.body;
¬† ¬† ¬† ¬† ¬† ¬† console.log("Intentando crear cuenta para:", nuevaCuenta.usuario);
¬† ¬† ¬† ¬† ¬† ¬† const hash = await bcrypt.hash(nuevaCuenta.clave, 12);
¬† ¬† ¬† ¬† ¬† ¬† crear("cuentas", { usuario: nuevaCuenta.usuario, hash }, async (err, cuenta) => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (err) { console.error("Error al crear cuenta en DB:", err); return next(err); }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (!cuenta || !cuenta.usuario) { console.error("Error: La funci√≥n 'crear' no devolvi√≥ una cuenta v√°lida."); return next(new Error("Error al crear la cuenta")); }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("Cuenta creada, generando token para:", cuenta.usuario);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const ficha = await crearFicha(cuenta.usuario);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("Token generado, enviando respuesta.");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† res.status(201).send({ token: ficha });
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } catch(fichaError) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.error("Error al crear ficha/token despu√©s de crear cuenta:", fichaError);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† next(fichaError);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† ¬† ¬† console.error("Error inesperado en /api/signup:", error);
¬† ¬† ¬† ¬† ¬† ¬† next(error);
¬† ¬† ¬† ¬† }
¬† ¬† }
);

/* POST Login (L√≥gica Completa Restaurada + Manejo Mejorado de pedirCuenta) */
router.post(
¬† ¬† "/login",
¬† ¬† cors(corsOptions), // üÜï Aplicar CORS espec√≠ficamente aqu√≠
¬† ¬† body("usuario").isEmail().withMessage("El formato del correo electr√≥nico es inv√°lido."),
¬† ¬† body("clave").isLength({ min: 5 }).withMessage("La clave debe tener un m√≠nimo de 5 caracteres."), // ‚¨ÖÔ∏è CAMBIO CLAVE AQU√ç
¬† ¬† async function (req, res, next) {
¬† ¬† ¬† ¬† // üëá *** Log inicial del handler *** üëá
¬† ¬† ¬† ¬† console.log("üî•üî•üî• ENTRANDO AL HANDLER POST /api/login (L√≥gica Completa) üî•üî•üî•");
¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† const errors = validationResult(req);
¬† ¬† ¬† ¬† ¬† ¬† if (!errors.isEmpty()) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("Errores de validaci√≥n en login:", errors.array());
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // Aseg√∫rate de no continuar si hay errores de validaci√≥n
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return res.status(400).json({ errors: errors.array() });
¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† const login = req.body;
¬† ¬† ¬† ¬† ¬† ¬† console.log(`Intentando login para usuario: ${login.usuario}`);

¬† ¬† ¬† ¬† ¬† ¬† // üëá *** Log ANTES de llamar a la BD *** üëá
¬† ¬† ¬† ¬† ¬† ¬† console.log("PASO 1: Llamando a pedirCuenta...");
¬† ¬† ¬† ¬† ¬† ¬† pedirCuenta(login.usuario, async (err, cuentaArray) => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // üëá *** Log DESPU√âS de llamar a la BD (o si hay error) *** üëá
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (err) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.error(`üí• ERROR en pedirCuenta para ${login.usuario}:`, err);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return next(err); // Pasa el error al manejador global
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("PASO 2: Respuesta de pedirCuenta recibida.");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("PASO 2b: Contenido de cuentaArray:", cuentaArray); // Log para depuraci√≥n

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const cuenta = cuentaArray && cuentaArray.length > 0 ? cuentaArray[0] : null;

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (!cuenta) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log(`Cuenta no encontrada para ${login.usuario}`);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // Devuelve un error claro y termina la ejecuci√≥n
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return res.status(404).send({ error: "Usuario no encontrado" });
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log(`PASO 3: Cuenta encontrada para ${login.usuario}. ID: ${cuenta.id}. Comparando clave...`);

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // üëá *** Log ANTES de bcrypt *** üëá
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† let result;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("PASO 4: Llamando a bcrypt.compare...");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† result = await bcrypt.compare(login.clave, cuenta.hash);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // üëá *** Log DESPU√âS de bcrypt *** üëá
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("PASO 5: bcrypt.compare completado. Resultado:", result);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } catch (bcryptError) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.error(`üí• ERROR en bcrypt.compare para ${login.usuario}:`, bcryptError);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return next(bcryptError); // Pasa el error
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (!result) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log(`Clave incorrecta para ${login.usuario}`);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // Devuelve un error claro y termina la ejecuci√≥n
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return res.status(401).send({ error: "Credenciales inv√°lidas" });
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log(`PASO 6: Clave correcta para ${login.usuario}. Creando token...`);

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // üëá *** Log ANTES de crear ficha/token *** üëá
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("PASO 7: Llamando a crearFicha...");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const ficha = await crearFicha(login.usuario);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // üëá *** Log DESPU√âS de crear ficha/token *** üëá
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("PASO 8: Ficha/Token creado exitosamente.");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log(` ¬† Enviando token para ${login.usuario}.`);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† res.send({ token: ficha }); // Env√≠a el token real
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } catch (fichaError) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.error(`üí• ERROR al crear ficha/token para ${login.usuario}:`, fichaError);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† next(fichaError); // Pasa el error
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† }); // Fin del callback de pedirCuenta
¬† ¬† ¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† ¬† ¬† // Captura cualquier error s√≠ncrono inesperado al inicio del handler
¬† ¬† ¬† ¬† ¬† ¬† console.error("üí• Error inesperado GENERAL en POST /api/login:", error);
¬† ¬† ¬† ¬† ¬† ¬† next(error); // Pasa el error al manejador global
¬† ¬† ¬† ¬† }
¬† ¬† } // Fin de la funci√≥n async del handler
);


// Ruta DELETE /api/usuarios/:id para eliminar usuario autenticado
router.delete('/usuarios/:id', autenticar, async (req, res, next) => {
¬† ¬† if (!req.usuario || req.usuario.id !== parseInt(req.params.id, 10)) {
¬† ¬† ¬† ¬† const userId = req.usuario ? req.usuario.id : 'desconocido';
¬† ¬† ¬† ¬† console.warn(`Intento no autorizado de borrar usuario ${req.params.id} por usuario ${userId}`);
¬† ¬† ¬† ¬† return res.status(403).json({ error: "No tienes permiso para borrar este usuario" });
¬† ¬† }
¬† ¬† try {
¬† ¬† ¬† ¬† const usuarioId = parseInt(req.params.id, 10);
¬† ¬† ¬† ¬† if (isNaN(usuarioId)) { return res.status(400).json({ error: "ID de usuario inv√°lido" }); }
¬† ¬† ¬† ¬† console.log(`Ô∏èüóëÔ∏è Intentando eliminar usuario y sus metas con ID: ${usuarioId}`);
¬† ¬† ¬† ¬† console.log(` ¬†Borrando metas para cuenta_id: ${usuarioId}...`);

¬† ¬† ¬† ¬† // Importa configuracion.js en lugar de conexion.js
¬† ¬† ¬† ¬† const db = require('../db/configuracion');

¬† ¬† ¬† ¬† // Eliminar metas usando el nombre de columna correcto 'cuenta_id'
¬† ¬† ¬† ¬† await pool.query('DELETE FROM metas WHERE cuenta_id = $1', [usuarioId]);

¬† ¬† ¬† ¬† console.log(` ¬†Borrando cuenta con id: ${usuarioId}...`);

¬† ¬† ¬† ¬† // Eliminar la cuenta
¬† ¬† ¬† ¬† await pool.query('DELETE FROM cuentas WHERE id = $1', [usuarioId]);

¬† ¬† ¬† ¬† console.log(`‚úÖ Usuario y metas eliminados para ID: ${usuarioId}`);
¬† ¬† ¬† ¬† res.status(204).end();
¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† console.error("‚ùå Error en la ruta de eliminaci√≥n /api/usuarios/:id :", error);
¬† ¬† ¬† ¬† next(error);
¬† ¬† }
});




// Funci√≥n para crear el token JWT
/*
function crearFicha(email) {
¬† ¬† return new Promise((resolve, reject) => {
¬† ¬† ¬† ¬† pedirCuenta(email, (err, [cuenta]) => {
¬† ¬† ¬† ¬† ¬† ¬† if (err) { console.error(`Error en pedirCuenta dentro de crearFicha para ${email}:`, err); return reject(err); }
¬† ¬† ¬† ¬† ¬† ¬† if (!cuenta) { console.error(`Cuenta no encontrada dentro de crearFicha para ${email}`); return reject(createError(404, "Cuenta no encontrada al crear ficha")); }
¬† ¬† ¬† ¬† ¬† ¬† if (!cuenta.id) { console.error("‚ùå Error: La cuenta recuperada no tiene ID en crearFicha"); return reject(createError(500,"Error interno del servidor: cuenta sin ID")); }
¬† ¬† ¬† ¬† ¬† ¬† console.log(`Creando ficha JWT para usuario: ${email}, ID: ${cuenta.id}`);
¬† ¬† ¬† ¬† ¬† ¬† let ficha;
¬† ¬† ¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ficha = jwt.sign( { exp: Math.floor(Date.now() / 1000) + (60 * 60), usuario: email, id: cuenta.id }, process.env.JWT_SECRET || "secreto", { algorithm: 'HS256' } );
¬† ¬† ¬† ¬† ¬† ¬† } catch(jwtError) { console.error("Error al firmar JWT:", jwtError); return reject(createError(500, "Error al generar token")); }
¬† ¬† ¬† ¬† ¬† ¬† console.log("Ficha JWT creada exitosamente.");
¬† ¬† ¬† ¬† ¬† ¬† resolve(ficha);
¬† ¬† ¬† ¬† });
¬† ¬† });
}
*/
function crearFicha(email) {
¬† ¬† // üö® ESTE C√ìDIGO FUE MODIFICADO
¬† ¬† const EXPIRACION_TEST = '10m'; // üëà ¬°1 MINUTO PARA PRUEBAS!

¬† ¬† return new Promise((resolve, reject) => {
¬† ¬† ¬† ¬† pedirCuenta(email, (err, [cuenta]) => {
¬† ¬† ¬† ¬† ¬† ¬† if (err) { console.error(`Error en pedirCuenta dentro de crearFicha para ${email}:`, err); return reject(err); }
¬† ¬† ¬† ¬† ¬† ¬† if (!cuenta) { console.error(`Cuenta no encontrada dentro de crearFicha para ${email}`); return reject(createError(404, "Cuenta no encontrada al crear ficha")); }
¬† ¬† ¬† ¬† ¬† ¬† if (!cuenta.id) { console.error("‚ùå Error: La cuenta recuperada no tiene ID en crearFicha"); return reject(createError(500,"Error interno del servidor: cuenta sin ID")); }
¬† ¬† ¬† ¬† ¬† ¬† console.log(`Creando ficha JWT para usuario: ${email}, ID: ${cuenta.id}`);
¬† ¬† ¬† ¬† ¬† ¬† let ficha;
¬† ¬† ¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // ‚úÖ CAMBIO CLAVE: Usamos 'expiresIn' en lugar de calcular 'exp' manualmente
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ficha = jwt.sign( 
                    { usuario: email, id: cuenta.id }, 
                    process.env.JWT_SECRET || "secreto", 
                    { 
                        expiresIn: EXPIRACION_TEST, // Usamos la variable de 1 minuto
                        algorithm: 'HS256' 
                    } 
                );
¬† ¬† ¬† ¬† ¬† ¬† } catch(jwtError) { console.error("Error al firmar JWT:", jwtError); return reject(createError(500, "Error al generar token")); }
¬† ¬† ¬† ¬† ¬† ¬† console.log("Ficha JWT creada exitosamente.");
¬† ¬† ¬† ¬† ¬† ¬† resolve(ficha);
¬† ¬† ¬† ¬† });
¬† ¬† });
}

module.exports = router;